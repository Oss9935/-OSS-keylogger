2. 소개 

2.1. 커널 모듈이란 

당신은 커널 모듈을 작성하려고 한다. C를 알고 프로세스로 작동하는 일반적인 프로그램을 작성해 봤고 이제는 어디서 실질적인 작업이 행해지는지, 하나의 와일드 포인터가 파일 시스템을 완전히 지울 수 있고 코어 덤프가 시스템의 리부팅을 의미한다는 것을 알고 있다. 

커널 모듈이란 정확히 무엇인가? 모듈이란 요구에 따라 커널에 적재 되거나 해제 될 수 있는 코드다. 시스템의 재가동 없이 커널의 기능을 확장을 가능케하는 것이다. 예로 모듈의 한 종류는 디바이스 드라이버다. 그리고 그것은 시스템에 연결된 하드웨어에 커널이 접근할 수 있도록 해 준다. 모듈이 없다면 우리는 모놀리틱 커널을 다시 빌드 해야 하며, 커널 이미지에 새로운 기능을 직접적으로 추가 시켜야 한다. 대규모 커널에서는, 우리가 원하는 새로운 기능을 추가 하기 위해서 매번 커널을 다시 빌드해야 하고, 다시 부팅해야하는 단점을 갖게 된다. 

2.2. 어떻게 모듈을 커널에 넣을 것인가? 

lsmod를 실행함으로써 당신은 이미 커널에 적재되있는 모듈을 볼 수 있으며, lsmod는 /proc/modules 파일을 읽어 정보를 얻어 온다.

모듈은 커널에서 어떻게 자신의 위치를 찾아낼까? 커널 내부에 존재하지 않는 특징을 커널이 알 필요가 있을 때, 커널 모듈 데몬인 kmod(이전 버전의 리눅스에서는 kerneld로 알려져 있다.) 모듈을 로드 시키기 위해 modprobe를 실행 시킨다. modprobe에 다음의 두 형태로 문자열이 전달된다.

softdog 혹은 ppp 같은 모듈이름
char-major-10-30 같은 일반적인 아이덴티파이어 

modprobe가 일반적인 아이덴티파이어를 전달 받는다면, 그것은 /etc/modules.conf 파일에서 그 문자열을 찾는다. 다음과 같은 알리어스 행을 찾는다면
 alias char-major-10-30 softdog
일반적인 아이덴티파이어는 softdog.o라는 모듈을 참조한다는 사실을 알게 된다.

다음으로 modprobe는 /lib/modules/version/modules.dep 파일을 조사해서 다른 모듈이 요구되는 모듈이 적재되기 전에 먼저 적재되야 하는가를 본다. 이 파일은 depmod -a 에 의해 생성되며, 모듈의 의존성을 담고 있다. 예를 들어 msdos.o는 fat.o모듈이 먼저 커널에 적재된 상태를 요구한다. 요청된 모듈이 사용하는 심볼(변수나 함수)을 다른 모듈이 정의 했는가라는, 다른 모듈에 대한 의존성을 갖는다.

마지막으로 modprobe는 선행 모듈을 커널에 적재하기 위해 insmod를 사용하고, 요구된 모듈을 적재한다. modprobe는 insmod에 표준 모듈 디렉토리인 /lib/modules/version/을 사용하도록 지시한다. insmod는 모듈의 위치에 대한 정보를 전혀 모르게 되있다. 반면에 modprobe는 모듈의 기본 위치를 알고 있다. 예를 들어 msdos모듈을 적재하기 원한다면 다음의 두 가지를 실행해야 한다.

insmod /lib/modules/2.5.1/kernel/fs/fat/fat.o
insmod /lib/modules/2.5.1/kernel/fs/msdos/msdos.o
혹은 "modprobe -a msdos"를 실행하자.

리눅스는 modprobe, insmode, depmod를 modutils혹은 mod-utils라 불리는 패키지로 제공한다

이장을 마치기 전에 /etc/modules.conf를 살펴보자.
#This file is automatically generated by update-modules
path[misc]=/lib/modules/2.4.?/local
keep
path[net]=~p/mymodules
options mydriver irq=10
alias eth0 eepro
#으로 시작하는 행은 주석이며, 빈 행은 무시된다.

path[misc] 행은 modprobe에 /lib/modules/2.4.?/local 디렉토리에서 misc 모듈에 대한 경로를 찾아 대체하도록 한다. 보듯이, 쉘 메타 캐릭터가 사용 가능하다. 

path[net] 행은 modprobe로 하여금 net 모듈을 ~p/modules/ 디렉토리에서 찾도록 한다. 그러나 pathnet에 바로 선행되는 “keep”은 modprobe에게 misc모듈에서 한 것처럼 표준 검색 경로를 대체하지 않고, 해당 디렉토리를 net모듈을 찾을 때 표준 검색 경로로 추가하도록 한다. 

kmod가 일반적인 아이덴티파이어인 ‘eth0’를 적재하라는 요구할 때마다, eepro.o를 적재하라고 한다. 

/etc/modules.conf 에서 "alias block-major-2 floppy"같은 행은 발견하지 못할 것이다. 왜냐햐면, modprobe는 대부분의 시스템에서 사용되는 표준 드라이버들에 대해 알고 있기 때문이다. 

이제 모듈이 어떻게 커널에 적재되는지 알았을 것이다. ‘stacking modules’라고 부르는 모듈에 의존적인 모듈을 작성한다면 몇 가지 더 언급할 것들이 있다. 이것은 다음으로 미룬다. 상대적으로 고 난이의 쟁점을 다루기 전에 다뤄야 할 부분이 많이 있다. 